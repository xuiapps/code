using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Build.Locator;
using System.Text;

namespace XuiApiExporter
{
    /// <summary>
    /// Goes through Xui code, replaces all method blocks with no-statement implementation like { /* ... */ }
    /// and saves it into a single markdown, hopefully a AI can pick up on that and learn from the API ref how to code with Xui.
    /// </summary>
    internal class Program
    {
        static async Task Main()
        {
            // --- Config ---
            const string solutionPath = "Xui.sln"; // Adjust relative or absolute path
            var projectNames = new[] { "Core" }; // Add your Xui projects here

            // --- Setup ---
            MSBuildLocator.RegisterDefaults();
            var workspace = MSBuildWorkspace.Create();
            Console.WriteLine("Loading solution...");
            var solution = await workspace.OpenSolutionAsync(solutionPath);

            var sb = new StringBuilder();
            var projectNameSet = projectNames.ToHashSet();

            // Add header level 1 and description
            sb.AppendLine("# Xui API Reference for AI Consumption");
            sb.AppendLine();
            sb.AppendLine("_Generated on " + DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm") + " UTC_");
            sb.AppendLine();
            sb.AppendLine("This document is an automatically generated API reference extracted directly from the Xui source code.");
            sb.AppendLine("It is optimized for AI models to efficiently understand the framework.");
            sb.AppendLine();

            foreach (var project in solution.Projects)
            {
                if (projectNameSet.Count > 0 && !projectNameSet.Contains(project.Name))
                    continue;

                Console.WriteLine($"Processing project: {project.Name}");
                var projectDir = new FileInfo(project.FilePath!).Directory!.FullName;

                // Add assembly header (level 2)
                sb.AppendLine($"## Assembly: {project.Name}");
                sb.AppendLine();

                foreach (var document in project.Documents.OrderBy(d => d.FilePath))
                {
                    if (document.SourceCodeKind != SourceCodeKind.Regular)
                        continue;

                    var fileName = Path.GetFileName(document.FilePath!);
                    if (fileName.Contains("AssemblyInfo"))
                        continue;

                    var text = await document.GetTextAsync();
                    if (text.Lines.Count > 0 && text.Lines[0].ToString().Contains("<auto-generated"))
                        continue;

                    var syntaxTree = await document.GetSyntaxTreeAsync();
                    if (syntaxTree == null)
                        continue;

                    var root = await syntaxTree.GetRootAsync();

                    // Replace method bodies, property bodies, indexers and expression bodies with { /* ... */ }
                    var rewriter = new MethodBodyStripper();
                    var simplifiedRoot = rewriter.Visit(root);

                    // Add file header (level 3)
                    sb.AppendLine($"### {Path.GetRelativePath(projectDir, document.FilePath!)}");
                    sb.AppendLine();
                    sb.AppendLine("```csharp");
                    sb.AppendLine(simplifiedRoot.NormalizeWhitespace().ToFullString());
                    sb.AppendLine("```\n");
                }
            }

            var outputPath = Path.Combine("www", "ai", "ai-api-ref.md");
            Directory.CreateDirectory(Path.GetDirectoryName(outputPath)!);
            File.WriteAllText(outputPath, sb.ToString());

            Console.WriteLine($"Done! Markdown output saved to: {outputPath}");
        }
    }

    class MethodBodyStripper : CSharpSyntaxRewriter
    {
        public override SyntaxNode? VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            if (node.Body != null || node.ExpressionBody != null)
            {
                var newBody = SyntaxFactory.Block(SyntaxFactory.ParseStatement("/* ... */"));
                node = node.WithBody(newBody)
                          .WithExpressionBody(null)
                          .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None));
            }
            return base.VisitMethodDeclaration(node);
        }

        public override SyntaxNode? VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
        {
            if (node.Body != null)
            {
                var newBody = SyntaxFactory.Block(SyntaxFactory.ParseStatement("/* ... */"));
                node = node.WithBody(newBody);
            }
            return base.VisitConstructorDeclaration(node);
        }

        public override SyntaxNode? VisitAccessorDeclaration(AccessorDeclarationSyntax node)
        {
            if (node.Body != null || node.ExpressionBody != null)
            {
                var newBody = SyntaxFactory.Block(SyntaxFactory.ParseStatement("/* ... */"));
                node = node.WithBody(newBody)
                           .WithExpressionBody(null)
                           .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None));
            }
            return base.VisitAccessorDeclaration(node);
        }

        public override SyntaxNode? VisitOperatorDeclaration(OperatorDeclarationSyntax node)
        {
            if (node.Body != null || node.ExpressionBody != null)
            {
                var newBody = SyntaxFactory.Block(SyntaxFactory.ParseStatement("/* ... */"));
                node = node.WithBody(newBody)
                          .WithExpressionBody(null)
                          .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None));
            }
            return base.VisitOperatorDeclaration(node);
        }

        public override SyntaxNode? VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
        {
            if (node.Body != null || node.ExpressionBody != null)
            {
                var newBody = SyntaxFactory.Block(SyntaxFactory.ParseStatement("/* ... */"));
                node = node.WithBody(newBody)
                          .WithExpressionBody(null)
                          .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None));
            }
            return base.VisitConversionOperatorDeclaration(node);
        }

        public override SyntaxNode? VisitPropertyDeclaration(PropertyDeclarationSyntax node)
        {
            if (node.ExpressionBody != null)
            {
                var newBody = SyntaxFactory.AccessorList(SyntaxFactory.List(new[]
                {
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                        .WithBody(SyntaxFactory.Block(SyntaxFactory.ParseStatement("/* ... */")))
                }));
                node = node.WithAccessorList(newBody)
                           .WithExpressionBody(null)
                           .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None));
            }
            return base.VisitPropertyDeclaration(node);
        }

        public override SyntaxNode? VisitIndexerDeclaration(IndexerDeclarationSyntax node)
        {
            if (node.ExpressionBody != null)
            {
                var newBody = SyntaxFactory.AccessorList(SyntaxFactory.List(new[]
                {
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                        .WithBody(SyntaxFactory.Block(SyntaxFactory.ParseStatement("/* ... */")))
                }));
                node = node.WithAccessorList(newBody)
                           .WithExpressionBody(null)
                           .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None));
            }
            return base.VisitIndexerDeclaration(node);
        }
    }
}
